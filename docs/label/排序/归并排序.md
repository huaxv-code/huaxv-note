# 归并排序

归并排序的时间复杂度是 $O(nlog(n))$ 时间稳定。

```c++ title="归并排序模板"
int a[N], b[N], n;

void merge(int l, int mid, int r)
{
	int i = l, j = mid + 1, t = 0;
	while (i <= mid && j <= r)
	{
		if (a[i] > a[j]) b[t ++] = a[j ++];
		else b[t ++] = a[i ++];
	}
	while (i <= mid) b[t ++] = a[i ++];
	while (j <= r) b[t ++] = a[j ++];
	for (i = 0; i < t; i ++) a[l + i] = b[i];
}

void msort(int l, int r)
{
	if (l >= r) return;
	int mid = (l + r) / 2;
	msort(l, mid);
	msort(mid + 1, r);
	merge(l, mid, r);
}
```

序列中逆序对的数量，例如对于序列 $1, 2, 6, 3, 4, 5$ 逆序对有 $<6, 3>、<6, 4>、<6, 5>$ 总共 $3$ 个。

对于归并排序，若序列长度只有 $2$ 个，例如 ：$2,1$

!!! question

    `bobo` 有一个长度为 $n$ 的非负整数序列 $a_1, a _ 2, a_3, \cdots , a _ n$，他至多允许你交换 $k$ 次相邻数。

    逆序对的定义：对于 $1 \leq l \leq r \leq n$ ，若 $a_i > a_j$ 就为一对逆序对，用语言描述就是大的排在小的左边，就为一对逆序对。

    请求出交换之后的逆序对最少数量。

    **输入格式**

    对于每个测试样例，第一行有两个整数 $n，k$，第二行有 $n$ 个整数。

    ```
    3 1 
    2 2 1
    3 0
    2 2 1
    ```

    **输出格式**

    对于每个测试样例，输出一个整数并换行。

    ```
    1
    2
    ```