# 二叉树

## 结构体定义

```c++
struct Node
{
    int v; Node* l, * r;
    Node(int val = 0, Node* left = nullptr, Node* right = nullptr)
    {
        v = val; l = left; r = right;
    }
};
```

## pre 前序遍历

方法一：「递归」

```c++
// 「递归版」 前序遍历二叉树 a
void pre(Node* a)
{
    if (!a) return;
    printf ("%d ", a->v);
    pre(a->l); pre(a->r);
}
```

方法二：「循环 + 栈」

```c++
// 「循环 + 栈」 前序遍历二叉树 a
void pre(Node* a)
{
    stack<Node*> st; 
    st.push(a);
    while (st.size())
    {
        a = st.top(); st.pop();
        if (!a) continue;
        printf ("%d ", a->v);
        st.push(a->r); st.push(a->l);
    }
}
```

## in 中序遍历

方法一：「递归」

```c++
// 「递归版」 中序遍历二叉树 a
void in(Node* a)
{
    if (!a) return;
    in(a->l); 
    printf ("%d ", a->v);
    in(a->r);
}
```

方法二：「循环 + 栈」

```c++
// 「循环+栈」 中序遍历二叉树 a
void in(Node* a)
{
    stack<pair<Node*, int>> st;
    st.push({a, 0});
    while (st.size())
    {
        auto node = st.top(); st.pop();
        if (!node.first) continue;
        if (node.second == 1) 
        {
            printf ("%d ", node.first->v);
            continue;
        }
        st.push({node.first->r, 0});
        st.push({node.first, 1});
        st.push({node.first->l, 0});
    }
}
```

## post 后序遍历

方法一：「递归」

```c++
// 「递归版」 后序遍历二叉树 a
void post(Node* a)
{
    if (!a) return;
    post(a->l);
    post(a->r);
    printf ("%d ", a->v);
}
```

方法二：「循环 + 栈」

```c++
// 「循环+栈」 后序遍历二叉树 a
void post(Node* a)
{
    stack<pair<Node*, int>> st;
    st.push({a, 0});
    while (st.size())
    {
        auto node = st.top(); st.pop();
        if (!node.first) continue;
        if (node.second == 1)
        {
            printf ("%d ", node.first->v);
            continue;
        }
        st.push({node.first, 1});
        st.push({node.first->r, 0});
        st.push({node.first->l, 0});
    }
}
```