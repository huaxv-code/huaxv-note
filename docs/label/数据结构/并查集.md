# 并查集

「并查集」可以快速的合并同一类东西，可以有效的管理同一类事物

核心操作有 「合并两集合」、「查询所属集合」

并查集的每个操作平均时间为 $O(a(n))$ ，其中 $a$ 为「阿克曼函数的反函数」，平均操作几乎可以认为是一个很小的常数。

## init 初始化

初始时，每一个数据都代表一个独立的集合

```c++
void init()
{
    for (int i = 1; i < N; i ++)
        ds[i] = i, sz[i] = 1;
}
```

## find 

查找 pos 位置所属集合位置 pos`

```c++
int find(int pos)
{
    if (ds[pos] == pos) return pos;
    ds[pos] = find(ds[pos]); // 路径压缩
    return ds[pos];
}
```

## meld 

将两个集合合并为一个集合

```c++
void meld(int p1, int p2)
{
    int a = find(p1);
    int b = find(p2);
    if (a == b) return;
    if (sz[a] < sz[b]) swap(a, b);
    ds[b] = a; sz[a] += sz[b];
    // 将元素少的合并到元素大的，效率视乎会变高，因为整体到达根的路径长度会短了一点点。
}
```

??? note "并查集代码汇总"

    ```c++
    const int N = int (1e6 + 10);
    int ds[N], sz[N]; // 并查集，集合元素

    void init()
    {
        for (int i = 1; i < N; i ++)
            ds[i] = i, sz[i] = 1;
    }

    int find(int pos)
    {
        if (ds[pos] == pos) return pos;
        ds[pos] = find(ds[pos]);
        return ds[pos];
    }

    void meld(int p1, int p2)
    {
        int a = find(p1);
        int b = find(p2);
        if (a == b) return;
        ds[b] = a; sz[a] += sz[b];
    }
    ```