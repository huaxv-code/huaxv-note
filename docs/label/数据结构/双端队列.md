# 双端队列

两端都能进或出

![84cdf8c9a2b753fdfa5c78957460d435.png](:/d65537366bec4b29be786645895cb056)

规定 $q[0]$ 是左指针，$q[1]$ 是右指针，如果 $q[0]$ 和 $q[1]$ 在数值上相邻时，为空

init：

初始化时，$q[0] = 2, q[1] = 3$

```cpp
void init(int q[])
{
    q[0] = 2, q[1] = 3;
}
```

$q[0]$ 的取值范围：$[2, N - 1, N - 2, \cdots , 3]$
$q[1]$ 的取值范围：$[3, 4, \cdots, N - 1, 2]$

定义 $N - 1$ 与 $2$ 相邻

$q[1]$ 右移操作本应该是 `q[1] = q[1] + 1 == N ? 2 : q[1] + 1`，根据取值范围：$[2, N - 1] = [0, N - 3] + 2$ 优化成：`q[1] = (q[1] - 2 + 1) % (N - 2) + 2 = (q[1] - 1) % (N - 2) + 2`

$q[0]$ 的左移操作本应该是 `q[0] = q[0] - 1 == 1 ? N - 1 : q[0] - 1`，根据取值范围：$[N - 1, \cdots , 2] = [N - 3, \cdots , 0] + 2$ 优化成：`q[0] = (q[0] - 2 - 1 + N - 2) % (N - 2) = (q[0] - 3 + N - 2) % (N - 2) = (q[0] - 5 + N) % (N - 2) + 2`

empty：

所以 $q[0]$ 与 $q[1]$ 在 $[2, N - 1]$ 上左相邻，可表示为：$[0, N - 3]$ 上相邻，即 `((q[1] - 2) - (q[0] - 2) + (N - 2)) % (N - 2) == 1` 化简后：`(q[1] - q[0] + N - 2) % (N - 2)`

```cpp
bool empty(int q[])
{
	return (q[1] - q[0] + N - 2) % (N - 2) == 1;
}
```

size：

如果 $q[1] > q[0]$，$size = q[1] - q[0] - 1$；

如果 $q[1] < q[0]$，$size = q[1] - 2 + N - q[0] - 1 = q[1] - q[0] - 1 +  N - 2$；

综上：$size = (q[1] - q[0] - 1 +  N - 2) % (N - 2)$

```cpp
int size(int q[])
{
    return  (q[1] - q[0] - 1 +  N - 2) % (N - 2);
}
```

full：

实际上，数组能用的空间只有 $N - 4$

```cpp
bool full(int q[])
{
	return size(q) == N - 3;
}
```

push_left：

先将元素放入 $q[q[0]]$，$q[0]$ 再左移：`q[0] = (q[0] - 5 + N) % (N - 2) + 2`

```cpp
void push_left(int q[], int x)
{
    q[q[0]] = x; q[0] = (q[0] - 5 + N) % (N - 2) + 2;
}
```

push_right：

先将元素放入 $q[q[1]]$，$q[1]$ 再右移：`q[1] = (q[1] - 1) % (N - 2) + 2`

```cpp
void push_right(int q[], int x)
{
    q[q[1]] = x; q[1] = (q[1] - 1) % (N - 2) + 2;
}
```

pop_left：

先将 `q[0]` 右移：`q[0] = (q[0] - 1) % (N - 2) + 2`，再取出元素

```cpp
int pop_left(int q[])
{
    q[0] = (q[0] - 1) % (N - 2) + 2;
    return q[q[0]];
}
```

pop_right：

先将 `q[1]` 左移：`q[1] = (q[1] - 5 + N) % (N - 2) + 2`，再取出元素

```cpp
int pop_right(int q[])
{
    q[1] = (q[1] - 5 + N) % (N - 2) + 2;
    return q[q[1]];
}
```

left：

访问左指针元素

```cpp
int left(int q[])
{
    return q[(q[0] - 1) % (N - 2) + 2];
}
```

right：

访问右指针元素

```cpp
int right(int q[])
{
    return q[(q[1] - 5 + N) % (N - 2) + 2];
}
```

## 代码汇总

```cpp
const int N = int (1e5 + 10);
int q[N];

void init(int q[])
{
    q[0] = 2, q[1] = 3;
}

bool empty(int q[])
{
    return (q[1] - q[0] + N - 2) % (N - 2) == 1;
}

int size(int q[])
{
    return  (q[1] - q[0] - 1 +  N - 2) % (N - 2);
}

bool full(int q[])
{
    return size(q) == N - 3;
}

void push_left(int q[], int x)
{
    q[q[0]] = x; q[0] = (q[0] - 5 + N) % (N - 2) + 2;
}

void push_right(int q[], int x)
{
    q[q[1]] = x; q[1] = (q[1] - 1) % (N - 2) + 2;
}

int pop_left(int q[])
{
    q[0] = (q[0] - 1) % (N - 2) + 2;
    return q[q[0]];
}

int pop_right(int q[])
{
    q[1] = (q[1] - 5 + N) % (N - 2) + 2;
    return q[q[1]];
}

int left(int q[])
{
    return q[(q[0] - 1) % (N - 2) + 2];
}

int right(int q[])
{
    return q[(q[1] - 5 + N) % (N - 2) + 2];
}
```