# 树状数组

树状数组可以很快的求出区间和。

??? info "树状数组举例图"

    ![树状数组管理范围](../../img/树状数组管理范围.png){width=100%}

```text
ci 管理的区间为: [i - lowbit(i) + 1, i]
   管理的长度为：lowbit(i)

ci 的父节点 cp: p = i + lowbit(i)
```

改变某个节点的值时，要更新该节点的所有上级。

## lowbit 获取 x 的最右边的 1

```c++
// 101000
// 010111 + 1 = 011000
// 101000 & 011000 = 001000 = 8
int lowbit(int x)
{
    return (~x + 1) & x;
}
```

## init 造树

方法一：

假设 $a[N]$ 是数据数组，参考树的结构，我们发现可以不断的通过子节点的值累加确定父节点的值：

??? info "树状数组举例图"

    ![树状数组管理范围](../../img/树状数组管理范围.png){width=100%}

    从左往右扫描，通过确定 `c2、c3、a4` 的值推导出 `c4` 的值。

```c++
void init()
{
    for (int i = 1; i <= n; i ++)
    {
        c[i] += a[i];
        if ((j = lowbit(i)) <= n) c[j] += c[i];
    }
}
```

方法二：

预处理出前缀和数组。