# ST 表

ST 表是用于解决 **可重复贡献问题** 的数据结构。

若满足 $f[x, x] = q[x]$，且若 $[x, y] = [x, a] \cup [b, y]$，则 $f[x, y] = f\{f[x, a], f[b, y]\}$，都可称为 **可重复贡献问题**。

例如下图的「区间最值」，就满足可重复贡献问题

![](../../img/ST%20表可重复贡献图.png)

同样道理：「区间 RMQ」、「区间 GCD」都是可重复贡献问题。RMQ 表示询问区间的最值。

类似「动态规划」的设计过程，初始化时，先确定长度为 1 的最值，再确定长度为 2 的最值，再确定长度为 4 的最值，两两合并依此类推，不断倍增预处理出各区间段的最值。

假设我要求区间 $[l, r]$ 的最值，我们要寻找 $[l, r]$ 的两个子区间：$[l, a]、[b, r]$ 使得 $[l, a] \cup [b, r] = [l, r]$，从而有：$f[l, r] = f\{f[l, a], f[b, r]\}$。

为了简化代码的设计，我们统一用区间的起点、区间的长度来代码该区间：$f(l, len)$ 代表区间 $[l, l + 2 ^ {len} - 1]$ 的最值。

则区间 $[l, r]$ 的最值为：$f\{f(l, log(r - l + 1)), f(r - 2 ^ {log(r - l + 1)} + 1, log(r - l + 1))\}$

!!! note "P3865 【模板】ST 表"

    给定一个长度为 $N$ 的数列，和 $M$ 次询问，求出每一次 询问的区间 内 数字最大的值。

## read 快读

借助 `getchar` 加快数据的读取速度。

```c++
inline int read()
{
    int x = 0, f = 1; char c = getchar();
    while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
    while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
    return x * f;
}
```

## init 初始化 ST 表

```c++
const int N = int (1e7 + 10);
int n, m;
int a[N], f[N][N], lg2[N]; 
// a 代表数据数组
// f[l][len] 代表区间 [l, l + 1 << len - 1] 的最大值
// lg2[i] 代表 log(i) 的值
```