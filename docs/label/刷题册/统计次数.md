# 统计次数

??? question "[Acwing 3400](https://www.acwing.com/problem/content/description/3403/)"
    
    给定两个正整数 $n$ 和 $k$，请你求出从 $1 \sim n$ 这 $n$ 个正整数的十进制表示中 $k$ 出现的次数。

    **数据范围**

    $1 \leq$ `n` $\leq 10 ^ 6$

    $1 \leq$ `k` $\leq 9$

    **输入样例**

    $12 1$

    **输出样例**

    $5$

## 找规律

1. $0 \sim 9$ 中出现 `k` 的次数必定是 $1$；
2. $0 \sim 99$ 中出现 `k` 的次数必定是 $10 + 1 * 10$
3. $0 \sim 999$ 中出现 `k` 的次数必定是 $100 + (10 + 1 * 10) * 10$

若假设函数 `f(n)` 可以求出 $0 \sim 999···9$ n 个 $9$ 中出现 `k` 的次数，那么可以得到递推公式：

> `f(n) = pow(10, n - 1) + f(n - 1) * 10`

```cpp title="求出 0 到 n 个 9 中出现 k 的次数"
LL f(LL k)
{
	if (k <= 1) return k;
	LL res = pow(10, k - 1);
	return res + f(k - 1) * 10;
}
```

---

定义函数 `fk(n, k)` 可以求出 `n` 的十进制表示中出现 `k` 的次数，参考代码为：

```c++
LL fk(LL n, LL k)
{
	LL res = 0;
	while (n)
	{
		if (n % 10 == k) res ++;
		n /= 10;
 	}
 	return res;
}
```

---

那么如果知道了 `n` 是 `a` 位十进制数，并且最高位为 `c`，那么可以确定 `0 ~ c * pow(10, a - 1) - 1` 范围内 `k` 出现的次数为：

> `res += f(a - 1) * c`

接下来我们只需要从 `c * pow(10, a - 1)` 一直遍历到 `n` 一个数一个数的求出 `k` 出现的次数并累加即可，这样时间复杂度估测将至 $O(an)$，$a$ 为 $n$ 的位数。

??? success "代码参考"

    ```c++
    #include <iostream>
    #include <cmath>

    using namespace std;
    typedef long long LL;
    const int N = int (1e6 + 10);

    LL n, m;
    LL res;

    LL f(LL k)
    {
        if (k <= 1) return k;
        LL res = pow(10, k - 1);
        return res + f(k - 1) * 10;
    }

    LL fk(LL n, LL k)
    {
        LL res = 0;
        while (n)
        {
            if (n % 10 == k) res ++;
            n /= 10;
        }
        return res;
    }

    int main(void)
    {
        scanf ("%lld%lld", &n, &m);
        LL a = 0, b = n, c, d;
        while (b) a ++, b /= 10;
        c = n / (LL) (pow(10, a - 1));
        res += f(a - 1) * c;
        if (c > m) res += pow(10, a - 1);
        d = c * pow(10, a - 1);
        while (d <= n)
        {
            res += fk(d ++, m);
        }
        cout << res << endl;
        
        return 0;
    }
    ```

## 探究暴力代码的时间复杂度

??? success "暴力代码"

    ```c++
    #include <iostream>

    using namespace std;
    typedef long long LL;
    const int N = int (1e6 + 10);

    LL n, m, res;

    LL fk(LL n, LL k)
    {
        LL res = 0;
        while (n)
        {
            if (n % 10 == k) res ++;
            n /= 10;
        }
        return res;
    }

    int main(void)
    {
        cin >> n >> m;
        for (LL i = 1; i <= n; i ++) res += fk(i, m);
        cout << res << endl;
    }
    ```

时间复杂度估测为 $O(can)$，$c$ 为 $n$ 的最高位，$a$ 为 $n$ 的位数。